<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript笔记]]></title>
    <url>%2F2019%2F02%2F28%2FJavaScript%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript与Java的关系仅是语法相似，无其他任何关系，主要用于网页动态设计和交互。其国际标准为ECMAScript，最新标准ES6. 入门篇1.0 快速入门 JavaScript代码可以直接放在网页的任何地方，但一般将其放在&lt;head&gt;中。即&lt;html&gt;&lt;head&gt;&lt;script&gt;...&lt;/script&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;这种结构。 也可将JavaScript代码放在单独的.js文件中，然后通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入该文件。 可以在同一个页面引用多个.js文件，也可以在页面中多次编写&lt;script&gt;js代码...&lt;/script&gt;，浏览器按顺序执行。 编写工具：Visual Studio Code/Sublime Text/Notepad++ 调试方法：Chrome的console 1.1 基本语法 语法与Java类似，每个语句以;结束，语句块用{...}，注意;不是强制要求，浏览器中的JavaScript引擎会自动在语句结尾补齐;，建议自己加; {...}内的语句具有缩进，有助于理解，此外{...}可以嵌套形成层级结构，但过多的层级会增加看懂代码的难度，通用做法是把部分代码抽出来作为函数来调用，减少代码的复杂度。 //:行注释， /*...*/：块注释 JavaScript严格区分大小写 1.2 数据类型和变量 数字。JavaScript不区分整数和浮点数，统一用Number表示。一般用16进制表示整数，如0xa5b4c3d2，Number可以直接做四则运算，规则与数学一致。 字符串。以&#39;&#39;或&quot;&quot;括起来的任意文本。注，这里的引号不是字符串的一部分。 布尔值。布尔值：true，false。布尔运算：&amp;&amp;-与运算；||-或运算；！-非运算。布尔值常用于条件判断中。 比较运算符。通过比较运算符得到一个布尔值，JavaScript允许对任意数据类型作比较。（注意：i)有2种比较运算符，==会自动转换数据类型再比较，很多时候会得到奇怪的结果；===不会自动转换，如果数据类型不一致，返回false。因此应坚持使用===。ii)NaN这个特殊的Number与所有其它值都不相等，包括他自己，唯一能判断NaN的方法是isNaN()函数。iii)浮点数在运算中会产生误差，因此比较两个浮点数是否相等只能计算他们之差的绝对值，看是否小于某个阈值） null和undefined。null表示空，undefined表示值未定义。大多数情况下应该用null，undefined仅仅在判断函数参数是否传递的情况下有用。 数组。JavaScript的数组可以包括任意数据类型，是一组按顺序排列的集合，数组用[]表示，元素用，分隔，创建数组也可用Array()函数实现，但建议用[]直接生成数组。 对象。JavaScript的对象是一组由键-值组成的无序集合，对象的键都是字符串类型，值可以是任意数据类型。每个键又称为对象的属性，获取对象的属性通过‘对象变量.属性名’的方式。 变量。变量可以是任意数据类型，变量名是大小写英文、数字、$和_的组合，且不能数字开头。变量名不能是JavaScript的关键字，声明变量用var语句，赋值用=，同一个变量可以反复赋值，而且可以是不同类型的变量，但是注意只能用var声明一次，因此JavaScript属于动态语言。 strict模式。如果一个变量没有通过var声明就被使用，那么该变量自动被声明为全局变量。strict模式下代码强制通过var声明变量，未使用var声明变量就使用的将导致错误。启用strict模式的方法是在JavaScript代码第一行写上&#39;use strict&#39;; 1.3 字符串 多行字符串。由于多行字符串用\n写比较麻烦，ES6中新增了反引号法，即...; 模板字符串。+可以拼接字符串，ES6中新增字符串{不带引号}, ${变量名}, __${}__;的方式实现字符串拼接。 操作字符串。变量名.length;返回字符串长度。字符串是不可变的，对某个索引赋值，不会报错，但也无任何作用。 字符串的常用方法。注：调用这些方法不会改变原有字符串内容，而是返回一个新字符串。变量名.toUpperCase();–全部变大写；变量名.toLowerCase();–全部变小写；变量名.indexOf(&#39;指定字符串&#39;);–返回指定字符串的位置，若无则-1；变量名.substring(x, y);–返回指定区间的字串，注意[x,y)。substring(x);表示从x到最后。 注：字符串越界显示为空（.substring()），数组越界显示为[]，（.slice()）。 1.4 数组 直接给Array的length赋一个新值会导致Array大小的变化。对Array的索引赋值会直接修改Array。通过索引赋值时，若索引超出了范围，同样会引起Array大小的变化。不建议直接修改Array的大小，访问索引时确保不越界。 indexOf。与字符串功能一致。 slice。类似字符串中的substring()。 push()–尾部添加若干元素，pop()–删除最后一个元素。空数组pop不会报错，而是返回undefined。 unshift()–头部添加若干元素，shift()–删除第一个元素。空数组shift不会报错，返回undefined。 sort()–数组排序。 reverse()–数组反转。 splice()–修改Array的万能法，可从指定索引开始删除若干元素，然后再从该位置添加若干元素。（案例：从2开始删3个，再加2个：arr.splice(2, 3, &#39;qw&#39;, &#39;eqwe&#39;)；只删除不添加：arr.splice(2,2)；只添加不删除：arr.splice(2, 0, &#39;dda&#39;, &#39;eeasd&#39;)） concat()。连接2个数组，返回一个新的数组。concat()方法并没有修改当前数组，而是返回一个新的数组。注：concat()方法可以接收任意个元素和数组，并且自动把数组拆开，然后再添加到新数组中。（如：var arr=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]; arr.concat(1,2,[3,4]); 返回的是[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,1,2,3,4]）。 join()。把数组中的每个元素用指定的字符串连接起来，然后返回连接后的字符串。若数组的元素不是字符串，则自动转换为字符串后再连接。 多维数组。即数组的元素中也包含数组。索引按嵌套方式。如：arr[2][2]。 1.5 对象 JavaScript的对象是一种无序的集合数据类型，由若干键值对组成，用于描述现实世界中的某个对象。 JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开，最后一个键值对不要加,。访问属性通过.操作符完成，但要求属性名必须是一个有效的变量名，若属性名包含特殊字符，就必须用’’括起来。这种情况下访问时必须用对象名[&#39;xxx&#39;]，而不能用对象名.属性了。注意：访问不存在的属性会返回undefined。 由于JavaScript是动态类型的，因此可以自由地给一个对象添加或删除属性，检测对象是否拥有某一属性，可以用in操作符。注：in判断属性存在，该属性不一定是对象的，可能是该对象继承得来的，因此判断属性是否是对象自身拥有的而非继承，可以用hasOwnProperty()方法。 1.6 条件判断 JavaScript使用if () {...} else {...}来进行条件判断，建议{}不要省略。 多重条件判断，if () {...} else if () {...} else {...}。 JavaScript把null，undefined，0，NaN和’’视为false，其他均为true。 1.7 循环 JavaScript的循环有2种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块。如： 123456var x = 0; var i; for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125; for循环最常用于利用索引遍历数组。for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，必须使用break语句退出循环，否则就是死循环。 for ... in。是for循环的一个变体，可以把一个对象的所有属性依次循环出来。要过滤掉对象继承的属性，用hasOwnProperty()来实现。由于数组也是对象，而他的每个元素的索引被视为对象的属性，因此for…in循环可以直接循环出数组的索引。注：for…in对数组的循环得到的是String而不是Number。如： 123456var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; for (var i in a) &#123; console.log(i); console.log(a[i]);&#125; while。while循环只有一个判断条件，条件满足，就不断循环。while () {...} do...while。它和while的唯一区别是不是在每次循环开始时判断条件，而是在每次循环完成的时候判断条件。注意，该循环至少执行一次而for和while循环则可能一次都不执行。do {...} while (); 1.8 Map和Set Map和Set是ES6新增的数据类型，类似于字典。 Map是一组键值对的结构，具有极快的查找速度。初始化Map需要一个二维数组，或者直接初始化一个空Map，Map具有以下方法。 1234567var m = new Map(); // 空Map m.set(&apos;Adam&apos;, 67); // 添加新的key-value m.set(&apos;Bob&apos;, 59); m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true m.get(&apos;Adam&apos;); // 67 m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos; m.get(&apos;Adam&apos;); // undefined。 由于一个key只能对应一个value，所以多次对一个key放入value，后面的值会冲掉前面的值。 Set和Map类似，也是一组key的集合，但不存储value，在Set中，没有重复的key。重复元素在Set中自动被过滤。通过add(key)方法可以添加元素，通过delete(key)方法删除元素。 1.9 iterable 遍历Array可以使用下标，遍历Map和Set无法使用下标，为了统一集合类型，ES6引入了iterable类型，Array,Map,Set都属于iterable类型，具有iterable类型的集合可以通过新的for…of循环来遍历。 for…of的用法。 123456789101112var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); for (var x of a) &#123; // 遍历Array console.log(x); &#125; for (var x of s) &#123; // 遍历Set console.log(x); &#125; for (var x of m) &#123; // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]);&#125; for…in和for…of的区别。for…in会把新增的属性包括在内 ，而Array的length却不包括在内。for…of只循环集合本身的元素。 更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。方法如下： 123456789101112131415var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element, index, array) &#123; console.log(element + &apos;, index = &apos; + index); &#125;); var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); s.forEach(function (element, sameElement, set) &#123; console.log(element); &#125;); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); m.forEach(function (value, key, map) &#123; console.log(value); &#125;); JavaScript的函数调用不要求参数必须一致，因此可以忽略不感兴趣的参数，如 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element) &#123; console.log(element); &#125;); 函数篇2.0 函数 几乎所有的高级语言都支持函数，JavaScript的函数不仅是“头等公民”，而且像可以变量一样使用，具有非常强的抽象能力。 2.1 函数定义和调用 定义函数。以下2种方式等价。因为函数实际上也是一个函数对象，函数名可以视为指向该函数的变量。注意第2种表述结尾的; 123456789101112131415function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 调用函数。调用函数时按顺序传入参数即可，传入的参数比定义的多或者少都没有问题，少的话，函数参数将收到undefined，计算结果为NaN。避免这种结果可采用“检查”，即： 12345678910function abs(x) &#123; if (typeof x !== &apos;number&apos;) &#123; throw &apos;Not a number&apos;; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; arguments。该关键字只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数，arguments类似Array但不是一个Array。常用于判断传入参数的个数。 12345678910// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125; rest参数。由于JavaScript函数允许接收人一个参数，因此不得不用arguments来获取所有参数，以下2种方式可以达到一样的效果。 1234567891011function foo(a, b) &#123; var i, rest = []; if (arguments.length &gt; 2) &#123; for (i = 2; i&lt;arguments.length; i++) &#123; rest.push(arguments[i]); &#125; &#125; console.log(&apos;a = &apos; + a); console.log(&apos;b = &apos; + b); console.log(rest);&#125; 1234567function foo(a, b, ...rest) &#123; console.log(&apos;a = &apos; + a); console.log(&apos;b = &apos; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5); 注：若传入的参数连正常定义的参数也未填满，rest参数会接收1个空数组，而不是undefined。 return语句不要换行，即return不要和后面的语句换行，否则会自动在return后加;，如要换行，请在return后加{。 2.2 变量作用域与解构赋值 var申明的变量实际上是有作用域的。如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，函数体外不可引用该变量。如果2个不同的函数各自申明了同一个变量，该变量只在各自的函数体内起作用，相互独立。嵌套函数中内部函数可以访问外部函数定义的变量，反之则不行。如果内部函数定义了和外部函数重名的变量，则内部函数的变量将屏蔽外部函数的变量。 变量提升。函数的特点之一是它会先扫描整个函数体的语句，把所有申明的变量提升到函数的顶部。因此，编码过程中应遵循“在函数内部首先申明所有变量”这一规则。注意：提升的是申明而不是赋值。 全局作用域。不在任何函数内定义的变量就具有全局作用域。JavaScript默认的一个全局对象是window，全局作用域的变量实际上被绑定到了window的一个属性。也即JavaScript实际上只有一个全局作用域。任何变量由下往上查找。 名字空间。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。如： 123456789// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 局部作用域。在for循环等语句块中无法定义具有局部作用域的变量，因此ES6引入关键字let，用let替代var可以申明一个块级作用域的变量。let的变量仅作用于循环内部。 常量。ES6以前，用全部大写的变量来表示常量，ES6引入关键字const定义常量，const也具有块级作用域。 解构赋值。可以同时对一组变量进行赋值。对数组进行解构赋值时，多个变量要用[...]括起来。 var [x, y, z] = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;]; 如果数组本身有嵌套，通过相同结构赋值，嵌套层次和位置要保持一致。 let [x, [y, z]] = [&#39;hello&#39;, [&#39;JavaScript&#39;, &#39;ES6&#39;]]; 解构赋值可以忽略某些元素。 let [, , z] = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;]; 如果需要从一个对象中取出若干属性，也可以使用解构赋值。 12345678var person = &#123; name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;&#125;;var &#123;name, age, passport&#125; = person; 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次一致。 12345678910111213var person = &#123; name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;, address: &#123; city: &apos;Beijing&apos;, street: &apos;No.1 Road&apos;, zipcode: &apos;100001&apos; &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person; 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量被赋值为undefined，如果要使用的变量名和属性名不一致，可通过下面语法获取： 1234567891011121314var person = &#123; name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id&#125; = person;name; // &apos;小明&apos;id; // &apos;G-12345678&apos;// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，避免不存在的属性返回undefined。有时候，如果变量已经被申明，再次赋值时正确的写法也会报错，是因为JavaScript引擎将{开头的语句当块处理了，所以=不在合法，解决方案是用()括起来， 1234567// 声明变量:var x, y;// 解构赋值:&#123;x, y&#125; = &#123; name: &apos;小明&apos;, x: 100, y: 200&#125;;// 语法错误: Uncaught SyntaxError: Unexpected token =(&#123;x, y&#125; = &#123; name: &apos;小明&apos;, x: 100, y: 200&#125;); 使用场景。常用于简化代码。如交换2个变量的值，快速获取当前页面的域名和路径等。注意：解构赋值特性是ES6支持的。 2.3 方法 在一个对象中绑定函数，称为这个对象的方法。绑定到对象上的函数称为方法，和普通函数没什么区别，但它在内部使用了this关键字，它是一个特殊变量，始终指向当前对象。注：JS的设计错误–如果一对象的方法形式调用，该函数的this指向被调用的对象，如果单独调用函数，此时this只想全局对象，即window。即要保证this指向正确，必须用obj.xxx()的形式调用。在strict模式下this指向undefined。 1234567891011var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 函数内部的函数的this指向undefined，修复的方法是在外函数内var that=this捕获this，然后在内函数中使用that代替this。 12345678910111213141516&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 apply。要指定函数的this指向哪个对象，可以用函数本身的apply方法，他接收2个参数，第一个参数是要绑定的this变量，第二个参数时Array，表示函数本身的参数。另一个与apply()类似的方法是call()，唯一区别是apply()把参数打包成Array再传入，call()把参数按顺序传入。对普通函数调用，通常把this绑定为null。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 装饰器。可以利用apply()动态改变函数的行为。JS的所有对象都是动态的，即使是内置的函数，我们也可以重新指向新的函数。 123456789&apos;use strict&apos;;var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;; 2.4 高阶函数由于变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称为高阶函数。 12345function add(x, y, f) &#123; return f(x) + f(y);&#125;var x = add(-5, 6, Math.abs); // 11console.log(x); 2.4.1 map/reduce map。map()作为高阶函数，把运算规则抽象了。如： 1234567&apos;use strict&apos;;function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); reduce。利用reduce()求积。 123&apos;use strict&apos;;function product(arr) &#123; return arr.reduce(function(x,y) &#123;return x*y;&#125;); 利用map和reduce实现string2int()函数。 12345&apos;use strict&apos;;function string2int(s) &#123; var arr=s.split(&apos;&apos;); arr=arr.map(function(x) &#123;return x*1;&#125;); return arr.reduce(function(x,y) &#123;return x*10+y;&#125;); 首字母大写。 1234&apos;use strict&apos;;function normalize(arr) &#123; return arr.map(function (s) &#123; return s[0].toUpperCase() + s.substring(1,s.length).toLowerCase();&#125;); 字符串变整数。 12345&apos;use strict&apos;;var arr = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];var r;r = arr.map(Number);console.log(r); 2.4.2 filter]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F02%2F26%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[说在前面Markdown是一种类似于HTML的标记语言，HTML由一对一对的标签组成，而Markdown则使用各种简单符号定义文本的类型，简单易学，让我们一起来开始吧。 标题标题一共有6种，分别用1-6个#标记，类比HTML中的h1-h6。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体常用字体主要就是粗体，斜体之类啦。 *我是斜体* **我是粗体** ***我是粗斜体，嘿嘿*** ~~我是被删除的根号三~~ 引用引用以&gt;开头，&gt;的多少影响的是引用的标记的长短，不信你看。 &gt; 我被标记了 &gt;&gt; 我也被标记了 &gt;&gt;&gt; 别说了，我也是 链接链接的个是比较固定，语法如下： [链接名称](连接的地址) 图片图片与链接类似，之在前面多了一个!而已。 ![图片名称](图片地址) 分割线分割线可用不少于3个*，-来标记，数量多少无明显差异，但是不能混用哦。 -------- **** 列表列表分为有序列表和无序列表，有序的如1,2,3等，无序的通常前面加个断点记号+，-，*等。 &lt;!-- 有序列表 --&gt; 1. 科学 2. 文化 3. 哲学 &lt;!-- 无序列表 --&gt; + 科学 + 文化 &lt;!-- 列表嵌套 --&gt; 1. 科学 - 天文 - 地理 - 物理 2. 文化 - 儒家 - 道家 - 释家 代码代码分为单行代码（如某些安装命令）和多行代码块（函数，循环等），分别用特殊符号引起来即可。当然，你也可以先写完，然后全部缩进一个TAB，也是一样的效果。 `我是一行代码` 1我是好多代码 表格表格稍微复杂一点，你可以把它看成几行几列的矩阵，填满每个格子即可，第一行是表头，一行一行描述即可。如下，第二行是用于分隔表头和内容的，此外，在此处可以定义文字的对齐方式，默认是左对齐，在-的右边加:则为右对齐，-的两边都加:则为居中，每一列的对齐方式都可以不同。 表头|表头|表头 -|-|- 内容|内容|内容 内容|内容|内容 内容|内容|内容 流程图不常用，很多编辑器也不支持，了解即可。 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用HEXO搭建个人博客]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建环境搭建博客到本地 下载 Node.js，并安装。 下载 Git， 并安装。 安装Hexo。 a. 搭建Hexo的环境，在Git Bash中运行以下命令： npm install -g hexo -cli b. 初始化Hexo，在Git Bash中运行以下命令： 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 即为存放Hexo初始化文件的路径，也即站点目录。新建之后在路径下会产生一些文件。 c. 启动服务器。在该路径下，使用Git Bush(即先定位到../../folder，然后右键Git Bash Here)，运行以下命令： hexo s d. 此时访问网址：http://localhost:4000 本地的博客已搭建成功。 将博客搭建到GitHub本地的博客只能本机访问，要想可通过网络访问，可借助GitHub实现。 创建GitHub账号并登陆。 创建仓库，仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages a. 安装hexo-deployer-git插件。在Git Bash运行以下命令即可： npm install hexo-deployer-git --save b. 添加SSH key。在Git Bash运行以下命令： ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到GitHub。复制密钥文件内容粘贴到New SSH key。 测试是否添加成功。在Git Bash运行以下命令：出现”you’ve successfully ….”即可。 12ssh -T git@github.comyes c. 修改站点目录下的配置文件 (_config.yml)。修改文件末尾： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master d. 回到gitbash中，进入你的blog目录，分别执行以下命令： 123hexo cleanhexo generatehexo deploy Hexo博客已经成功搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 主题优化启用Next主题前往https://hexo.io/themes/选择自己喜欢的主题并下载，复制到站点目录下的themes文件下，然后修改站点目录下的_config.yml文件中的Extensions部分，如下即可。12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextplugins: hexo-generate-feed 修改主题为中文修改站点目录下的_config.yml文件中的Site部分的language的值，修改为zh-Hans。 更改标题作者和链接修改站点目录下的_config.yml文件中的Site部分的title，subtitle的值，URL中的url的值即可。 更改主题样式修改next主题目录下的_config.yml文件中的Schemes部分，选择某一种主题，如：12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 增加关于标签分类页修改next主题目录下的_config.yml文件中的menu部分，开启about，tags,categories,如下，下略。123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增页面的正确打开方式若现在保存配置文件，然后素质三连123hexo cleanhexo ghexo s 在本地网页上看到的新增的3个页面都为空，且关于页面是404，因此需要一些额外的操作才能使这几个页面生效，此处以标签页为例，首先进到站点目录下的source文件夹下，右键Git Bash输入：hexo n page tags此时会发现source文件下多了一个tags文件夹，进去，打开index.md文件，编写其中内容，如：12345---title: 标签date: 2019-02-16 21:25:50type: &quot;tags&quot;--- 此时再打开标签页就会显示暂无标签。 更改并设置可旋转头像启用next主题目录下的_config.yml文件中的avatar，值为头像图片路径，建议将图片都放在：\blog\themes\next\source\images下，如：avatar: /images/luffy.jpg 然后定位到\blog\themes\next\source\css\_common\components\sidebar，编辑sidebar-author.styl文件，修改部分如下，其他部分不变，即可实现头像旋转：12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; transition: 2s all;&#125;.site-author-image:hover&#123; transform: rotate(360deg);&#125; 启用侧边栏社交链接启用next主题目录下的_config.yml文件中的social，启用想增加的社交连接，将链接改为自己的相应网站的个人主页网址即可。 启用友情链接启用next主题目录下的_config.yml文件中的links，按照文件中给的样式增加你想要添加的友情链接。 开启打赏功能启用next主题目录下的_config.yml文件中的Reward，开启reward_comment，wechatpay，alipay，修改它们的值。第一个表示求打赏的话，第2，3分别是微信，支付宝的付款吗图片。 开启订阅与RSS启用next主题目录下的_config.yml文件中的Wechat Subscriber，下面的4行全部开启，enabled值设为true，qcode的值为个人公众号二维码。 切换到站点目录下，安装插件npm install --save hexo-generator-feed，然后编辑站点目录下的_config.yml文件中的Extensions，在其下方添加一行代码：plugins: hexo-generate-feed，然后启用next主题目录下的_config.yml文件中的rss，修改为：1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 首页文章设置阅读全文修改next主题目录下的_config.yml文件中的auto_excerpt：12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 添加动态背景修改next主题目录下的_config.yml文件中的Canvas-nest，默认有4种背景可供选择，将想选的背景的值改为true即可。 添加fork GitHub在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码，将刚刚复制的挂饰代码，添加到Blog/themes/next/layout/_layout.swig文件中，放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下方即可。 修改文章内链接样式打开\blog\themes\next\source\css\_common\components\post\post.styl，在底部添加如下代码，即可实现鼠标移到该链接处字体变紫色的效果：1234567.post-body p a&#123; color: #345; border-bottom: none; &amp;:hover&#123; color: purple; &#125;&#125; 修改文章底部标签打开\blog\themes\next\layout\_macro\post.swig，修改第359行，将#替换成其他图标，可以在http://www.fontawesome.com.cn/faicons/寻找你想要的图标，如此出我们将#替换成了&lt;i class=&quot;fa fa-tag&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;。12345678&lt;footer class=&quot;post-footer&quot;&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class=&quot;post-tags&quot;&gt; &#123;% for tag in post.tags %&#125; &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; 增加来必力评论系统注册并登陆来必力获取你的LiveRe UID。填写LiveRe UID到主题配置文件_config.yml的livere_uid即可。 增加本地搜索功能安装插件，在站点的根目录下执行以下命令：npm install hexo-generator-searchdb --save，然后在站点配置文件中添加以下代码：123456# local_searchsearch: path: search.xml field: post format: html limit: 10000 然后启用主题目录下的配置文件中的local_search，值改为true即可。 增加不蒜子统计功能编辑主题配置文件中的busuanzi_count的配置项即可。如：1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访客数 &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: 本文总阅读量 &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 次 然后找到主题调用不蒜子的swig文件。一般在”\themes*\layout_third-party\analytics\busuanzi-counter.swig”，将原域名dn-lbstatics.qbox.me/改为busuanzi.ibruce.info/。 增加内容分享服务开启主题配置文件的jiathis，增加值为true即可。 增加加载效果开启主题配置文件的pace，值改为true，下面的list是所有的加载样式，选择其一复制到pace_theme即可。 显示当前浏览进度修改主题配置文件如下：12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 增加鼠标点击特效在/themes/next/source/js/src下新建文件clicklove.js，接着把以下粘贴到clicklove.js文件中。代码如下： !function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 然后在\themes\next\layout\_layout.swig文件末尾添加：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 隐藏底部的强力驱动找到\blog\themes\next\layout\_partials\footer.swig，注释掉24-41行这段代码即可。 增加字数统计和阅读时长功能先在站点目录下安装插件npm install hexo-wordcount --save，然后修改主题配置文件相应部分：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 添加二次元生物其实就是在博客中添加Live 2D模型。首先安装插件： npm install --save hexo-helper-live2d 然后下载模型文件，可在此处选择你喜欢的模型： npm install live2d-widget-model-shizuku 然后在站点配置文件和主题配置文件中添加以下配置： live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 注：model: use的值为你选择的模型名称，模型名称必须是你已下载的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>分享</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[测试文章第一篇文章这是一个三级标题 列表1 列表2 a 子列表1 b 子列表 列表3 有哪些值得推荐的字体？ 这是斜体字型这是粗体字型 &lt;html&gt;&lt;/html&gt; 123456789&lt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这是一部分引用内容]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
